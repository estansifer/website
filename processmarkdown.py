#!/bin/python

import sys
import os
import os.path as op
import shutil
import hashlib
import json
import base64

import pandocfilters as pf

import util
import texify
import filelayout

png_zoom_fudge = 1.15
png_depth_fudge = 0
png_zoom = 5

#
# Pandoc json format for representing math code --
#   key = "Math"
#   value = [style, formula]
#   where
#       style = {"t" : "InlineMath"} or
#       style = {"t" : "DisplayMath"}
#       and "formula" is a string representing the latex source
#
# Pandoc json format for representing an image link --
#   key = "Image"
#   value = [valueA, valueB, valueC]
#   valueA = [id, class_list, attr_list]
#   valueB = alt_text_element_list
#   valueC = [image_path, title_text]
#
#
#   id -- string with the identifier of the element
#   class_list -- list of strings with the classes of the element
#   attr_list -- list of pairs [key, value] with the attributes of the class;
#           key and value must be strings
#   alt_text_element_list -- list of elements that specifies the alt text.
#       Typically:
#       alt_text_element_list = [{"t":"Str","c":"This is the alt text"}]
#   image_path -- string giving the path to the image
#   title_text -- string giving the text to show on mouse over (i.e., the "title")
#

def gather_equations(j):
    equations = []
    def walker(key, value, format, meta):
        if key == 'Math':
            latex = value[1]
            inline = (value[0]['t'] == 'InlineMath')
            equations.append(texify.LatexEquation(latex, inline))

    pf.walk(j, walker, None, None)
    return equations

def get_image_path(image_element):
    return image_element[2][0]

def set_image_path(image_element, image_path):
    image_element[2][0] = str(image_path)

def create_image_element(image_path, **kwargs):
    _id = kwargs.get("id", "")
    classes = kwargs.get("classes", [])
    attrs = kwargs.get("attrs", [])
    title = kwargs.get("title", "")

    if "alt_elements" in kwargs:
        alt_elements = kwargs[alt_elements]
    elif ("alt_text" in kwargs) and (len(kwargs["alt_text"]) > 0):
        alt_elements = [{"t" : "Str", "c" : kwargs["alt_text"]}]
    else:
        alt_elements = []

    return {"t" : "Image", "c" :
            [
                [_id, classes, attrs],
                alt_elements,
                [image_path, title]
            ]
        }

# Returns path to the resource
def relocate_autogenerated_resource(source, mime = None):
    assert op.isfile(source)

    with open(source, 'rb') as f:
        data = f.read()

    inline = (mime is not None) and (len(data) <= 2000)

    if inline:
        b = base64.standard_b64encode(data)
        return 'data:' + mime + ';base64,' + b.decode()
    else:
        # 16 hexadecimal digits gives 16 ** 16 == 2 ** 64 possible hashes
        # Collisions are expected at around 2 ** 32 = 4 billion hashes
        h = hashlib.sha256(data).hexdigest()[:16]

        ext = op.splitext(source)[1]
        name = h + ext

        target = filelayout.path_to_auto_resource(name)
        shutil.copyfile(source, target)

        return filelayout.link_to_auto_resource(name)

def update_math(j, equations, use_png = True):
    equation_index = [0]

    def walker(key, value, format, meta):
        if key == 'Math':
            equation = equations[equation_index[0]]
            equation_index[0] += 1

            if use_png:
                image_path = equation.png_path
                geometry = equation.png_geometry
                zoom = png_zoom / png_zoom_fudge
                zoom_depth = png_zoom
                depth_fudge = png_depth_fudge
                mime = 'image/png'
            else:
                image_path = equation.svg_path
                geometry = equation.svg_geometry
                zoom = 1
                zoom_depth = 1
                depth_fudge = 0
                mime = 'image/svg'

            new_image_path = relocate_autogenerated_resource(image_path, mime)
            options = {}
            if equation.inline:
                options['classes'] = ['inlinemath', 'math']
            else:
                options['classes'] = ['displaymath', 'math']
            options['alt_text'] = equation.alt_text()
            options['attrs'] = [
                    ['style', 'vertical-align: -{}px'.format(
                        (geometry[2] / zoom_depth) - depth_fudge)],
                    ['width', str(geometry[0] / zoom) + 'px'],
                    ['height', str((geometry[1] + geometry[2]) / zoom) + 'px']]
            return create_image_element(new_image_path, **options)

    return pf.walk(j, walker, None, None)

def make_links_relative(j, relroot):
    def walker(key, value, format, meta):
        if key in ['Image', 'Link']:
            a, b, c = value
            path, d = c

            if path.startswith('/'):
                newpath = relroot + path
                return {'t' : key, 'c' : [a, b, [newpath, d]]}

        return None

    return pf.walk(j, walker, None, None)

def process_markdown(doc, relative = True):
    if doc.source_data is None:
        pandoc_result = util.call(['pandoc', '-t', 'json',
            '-f', 'markdown', str(doc.source_path)])
    else:
        pandoc_result = util.call(['pandoc', '-t', 'json',
            '-f', 'markdown'], input = doc.source_data)

    j = json.loads(pandoc_result.stdout)

    equations = gather_equations(j)
    texify.makeimages(equations, make_png = True, make_svg = True, png_dpi = int(96 * png_zoom))
    j_new = update_math(j, equations)

    if relative:
        j_new = make_links_relative(j_new, doc.relroot)

    cmd = ['pandoc', '-s', '-f', 'json', '-t', 'html',
            '--template', doc.template] + doc.pandoc_variable_arguments()
    pandoc_result = util.call(cmd, input = json.dumps(j_new))

    doc.target_data = pandoc_result.stdout
